import fetch from 'node-fetch';
import loadLanguages from 'prismjs/components/index.js';
import { addAstro } from '@astrojs/prism';
import Prism$1 from 'prismjs';
import { h, Fragment } from '../dist/internal/h.js';

if(!('fetch' in globalThis)) {
  globalThis.fetch = fetch;
}


const __TopLevelAstro = {
  site: new URL("http://localhost:3000"),
  fetchContent: (globResult) => fetchContent(globResult, import.meta.url),
};
const __astroInternal = Symbol('astro.internal');
const __astroContext = Symbol.for('astro.context');
async function __render(props, ...children) {
  const Astro = Object.create(__TopLevelAstro, {
    props: {
      value: props,
      enumerable: true
    },
    css: {
      value: (props[__astroInternal] && props[__astroInternal].css) || [],
      enumerable: true
    },
    isPage: {
      value: (props[__astroInternal] && props[__astroInternal].isPage) || false,
      enumerable: true
    },
    request: {
      value: (props[__astroContext] && props[__astroContext].request) || {},
      enumerable: true
    }
  });

  const {
  lang,
  code
} = Astro.props;
const languageMap = new Map([["ts", "typescript"]]);
if (lang == null) {
  console.warn("Prism.astro: No language provided.");
}
const ensureLoaded = (lang2) => {
  if (lang2 && !Prism$1.languages[lang2]) {
    loadLanguages([lang2]);
  }
};
if (languageMap.has(lang)) {
  ensureLoaded(languageMap.get(lang));
} else if (lang === "astro") {
  ensureLoaded("typescript");
  addAstro(Prism$1);
} else {
  ensureLoaded("markup-templating");
  ensureLoaded(lang);
}
if (lang && !Prism$1.languages[lang]) {
  console.warn(`Unable to load the language: ${lang}`);
}
const grammar = Prism$1.languages[lang];
let html = code;
if (grammar) {
  html = Prism$1.highlight(code, grammar, lang);
}
let className = lang ? `language-${lang}` : "";

  return h(Fragment, null, h(Fragment, null,(Astro.isPage ? h(Fragment, null, h(Fragment, null, Astro.css.map((css) => h("link", { "rel": "stylesheet", "href": css, [__astroContext]: props[__astroContext] }))), h("script", { [__astroContext]: props[__astroContext] }, "window.HMR_WEBSOCKET_PORT = 12321;"), h("script", { "type": "module", "src": "/_snowpack/hmr-client.js", [__astroContext]: props[__astroContext] })) : null),h("pre", {"class":(className),[__astroContext]:props[__astroContext]},h("code", {"class":(className),[__astroContext]:props[__astroContext]},(html)))));
}
var Prism = { isAstroComponent: true, __render };

// `__renderPage()`: Render the contents of the Astro module as a page. This is a special flow,
// triggered by loading a component directly by URL.
async function __renderPage({request, children, props, css}) {
  const currentChild = {
    isAstroComponent: true,
    layout: typeof __layout === 'undefined' ? undefined : __layout,
    content: typeof __content === 'undefined' ? undefined : __content,
    __render,
  };

  Object.defineProperty(props, __astroContext, {
    value: {
      request
    },
    writable: false,
    enumerable: false
  });

  Object.defineProperty(props, __astroInternal, {
    value: {
      css,
      isPage: true
    },
    writable: false,
    enumerable: false
  });

  const childBodyResult = await currentChild.__render(props, children);

  // find layout, if one was given.
  if (currentChild.layout) {
    return currentChild.layout({
      request,
      props: {content: currentChild.content},
      children: [childBodyResult],
    });
  }

  return childBodyResult;
}

export default Prism;
export { __renderPage };
